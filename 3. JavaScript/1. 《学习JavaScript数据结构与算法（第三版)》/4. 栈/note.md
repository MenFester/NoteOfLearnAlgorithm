# 学习笔记

## 4.1 创建一个JavaScript数据结构和算法库

* 有两种类似于数组的数据结构在添加和删除元素时更为可控，它们就是栈和队列

## 4.2 栈数据结构

* 栈是一种遵从后进先出（LIFO）原则的有序集合
* 新添加或待删除的元素都保存在栈的同一端：栈顶（新元素靠近栈顶），另一端叫栈底（旧元素靠近栈底）
* 创建一个基于数组的栈：
  * 需要一种数据结构来保存栈里的元素：选择数组
  * 声明一个Stack类
  * 为栈声明一些方法：
    * push(element(s))：添加一个或几个新元素到栈顶
    * pop()：移除栈顶的元素，同时返回被移除的元素
    * peek()：返回栈顶的元素，不对栈做任何修改
    * isEmpty()：如果栈里没有任何元素就返回true，否则返回false
    * clear()：移除栈里的所有元素
    * size()：返回栈里元素的个数

## 4.3 创建一个基于JavaScript对象的Stack类

* 在使用数组时，大部分方法的时间复杂度是O(n)，如果数组有更多元素的话，所需的时间会更长
* 在基于JavaScript对象的Stack类版本中，将使用一个count属性来帮助我们记录栈的大小

## 4.4 保护数据结构内部元素

* Object.getOwnPropertyNames暴露了想要隐藏的属性，通过它们可以访问内部元素
* 方法一：通过使用下划线命名约定来标记一个属性为私有属性。这种方法只是约定，并不能保护数据
* 方法二：用ES2015的限定作用域Symbol实现类
  * `const _items = Symbol('stackItems'); `
  * 在constructor中，使用`this[_items] = []`
  * 这种方法创建了一个假的私有属性，通过Object.getOwnPropertySymbols(stack)还是可以获取
* 方法三：使用WeakMap（可以存储键值对）
  * `const items = new WeakMap();`
  * 在constructor中，使用`items.set(this, [])`，this指stack类自己
* 方法四：正在提案中，通过在属性前添加井号（#）作为前缀来声明私有属性

## 4.5 用栈解决问题

* 栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作
* 